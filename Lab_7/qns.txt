Part 1
------
Q1. Briefly explain your implementation logic to handle wrap-around in the trace buffer.

A1. We store pointers to the base, write and read. Whenever we need to see the offset, we subtract the base pointer. Whenever the read offset is more than write offset, we add size to write offset during pointer arithmatic. If read and write offset are same and last operation was write, we still add the size to write offset and make it more than size. (We handle these cases properly with temp variables).

Q2. Can a write to trace buffer return 0 even if we pass non-zero size to the system call? Why or Why not?

A2. Yes, if buffer is full.

Q3. Explain the expected behavior of testcase9.c.  

A3. File descriptors are default open for 0, 1, 2 and there are 32 total possible file descriptors, hence the fd[29] which is supposed to get fd 32, will not be allocated (possible range is 0-31).

Part 2
------
Q1. In testcase3.c, what address `caddr' represent? How it is formulated in the user space?

A1. In the stack, first we will have main and on top we will have the function get_my_code_addr's base pointer and on top of that we will have the address where we have to return after completing the function. After that we define and int and point to 2 entries below on the stack. Hence we are referring to the pointer where we shall return after completing the function and we are dereferencing it. This means caddr represents the address of the current instruction. This is the virtual address of the instruction not the real address. This address is stored in the code segment.

Q2. How do you explain the invocation of tb_read() and tb_write() when a read/write syscall is performed?   

A2. Using the type field in struct file, we can understand the type of structure we are reading or writing and hence the relevant calls are made.
